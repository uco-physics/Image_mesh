<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メッシュワープ画像加工（逆写像＋境界埋め版）</title>
    <style>
        body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
        canvas { border: 3px solid #000; max-width: 100%; margin: 5px; background: #f0f0f0; }
        .controls { margin: 20px 0; }
        .grid-point { position: absolute; width: 8px; height: 8px; background: red;
                      border-radius: 50%; transform: translate(-50%, -50%); cursor: move; }
        button, input, select { margin: 5px; padding: 5px; }
        #error { color: red; }
    </style>
</head>
<body>
    <h1>メッシュワープ画像加工（逆写像＋境界埋め版）</h1>
    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <div>
            <label>横の分割数: <input type="range" id="gridX" min="2" max="50" value="5">
                <span id="gridXValue">5</span></label>
        </div>
        <div>
            <label>縦の分割数: <input type="range" id="gridY" min="2" max="50" value="5">
                <span id="gridYValue">5</span></label>
        </div>
        <button onclick="resetGrid()">グリッドリセット</button>
        <button onclick="undo()">戻る</button>
        <button onclick="redo()">進む</button>
        <button onclick="saveImage()">画像保存</button>
    </div>
    <div id="error"></div>
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>

    <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const imageInput = document.getElementById('imageInput');
    const gridXInput = document.getElementById('gridX');
    const gridYInput = document.getElementById('gridY');
    const gridXValue = document.getElementById('gridXValue');
    const gridYValue = document.getElementById('gridYValue');
    const gridContainer = document.getElementById('gridContainer');
    const errorDiv = document.getElementById('error');

    let img = new Image();
    let imgData = null;
    let gridPoints = [];
    let gridX = 5, gridY = 5;
    let isDragging = false, draggedPoint = null;
    let canvasOffset = { x:0, y:0 };
    let history = [], historyIndex = -1;

    function showError(msg){ errorDiv.textContent = msg; console.error(msg); }

    imageInput.addEventListener('change', e => {
      const file = e.target.files[0];
      if(!file){ showError('画像が選択されていません'); return; }
      img.src = URL.createObjectURL(file);
      img.onload = () => {
        canvas.width = img.width; canvas.height = img.height;
        initGrid(); saveHistory();
        // 元ピクセルバッファ取得
        ctx.drawImage(img,0,0);
        imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
        draw(); errorDiv.textContent='';
      };
      img.onerror = ()=> showError('画像読み込み失敗');
    });

    function initGrid(){
      gridContainer.innerHTML = '';
      gridPoints = [];
      if(gridX>30||gridY>30) showError('警告: 分割数が多いと重くなります');
      for(let y=0;y<=gridY;y++){
        for(let x=0;x<=gridX;x++){
          const px = x*(canvas.width/gridX);
          const py = y*(canvas.height/gridY);
          gridPoints.push({ x:px, y:py, origX:px, origY:py });
          createGridPoint(px,py,gridPoints.length-1);
        }
      }
    }

    function createGridPoint(x,y,i){
      const d=document.createElement('div');
      d.className='grid-point';
      d.style.left=`${x}px`; d.style.top=`${y}px`;
      d.onmousedown=()=>{ isDragging=true; draggedPoint=i; };
      gridContainer.appendChild(d);
    }

    function updateGridDOM(){
      gridPoints.forEach((p,i)=>{
        const d=gridContainer.children[i];
        d.style.left=`${p.x}px`; d.style.top=`${p.y}px`;
      });
    }

    function resetGrid(){ 
      gridPoints.forEach(p=>{ p.x=p.origX; p.y=p.origY; });
      updateGridDOM(); saveHistory(); draw();
    }

    function saveHistory(){
      history=history.slice(0,historyIndex+1);
      history.push(JSON.stringify(gridPoints));
      historyIndex++;
      if(history.length>50){ history.shift(); historyIndex--; }
    }
    function undo(){
      if(historyIndex>0){
        historyIndex--;
        gridPoints = JSON.parse(history[historyIndex]);
        updateGridDOM(); draw();
      }
    }
    function redo(){
      if(historyIndex<history.length-1){
        historyIndex++;
        gridPoints = JSON.parse(history[historyIndex]);
        updateGridDOM(); draw();
      }
    }

    gridXInput.oninput = ()=> {
      gridX = +gridXInput.value; gridXValue.textContent=gridX;
      initGrid(); saveHistory(); draw();
    };
    gridYInput.oninput = ()=> {
      gridY = +gridYInput.value; gridYValue.textContent=gridY;
      initGrid(); saveHistory(); draw();
    };

    document.onmousemove = e => {
      if(isDragging && draggedPoint!==null){
        const rect = canvas.getBoundingClientRect();
        gridPoints[draggedPoint].x = e.clientX - rect.left;
        gridPoints[draggedPoint].y = e.clientY - rect.top;
        updateGridDOM();
        draw();
      }
    };
    document.onmouseup = ()=> {
      if(isDragging){ saveHistory(); }
      isDragging=false; draggedPoint=null;
    };

    // サンプリング（バイリニア）
    function sampleBilinear(data, sx, sy){
      const w=canvas.width, h=canvas.height;
      // 境界クランプ
      sx = Math.max(0,Math.min(w-1, sx));
      sy = Math.max(0,Math.min(h-1, sy));
      const x0 = Math.floor(sx), y0 = Math.floor(sy);
      const x1 = Math.min(w-1, x0+1), y1 = Math.min(h-1, y0+1);
      const dx = sx - x0, dy = sy - y0;
      const idx = (y0*w + x0)*4;
      const get = (xx,yy)=>{
        const i=(yy*w+xx)*4;
        return [data[i],data[i+1],data[i+2],data[i+3]];
      };
      const c00 = get(x0,y0), c10 = get(x1,y0), c01 = get(x0,y1), c11 = get(x1,y1);
      const mix = (a,b,t)=>a + (b-a)*t;
      const r = mix(mix(c00[0],c10[0],dx), mix(c01[0],c11[0],dx), dy);
      const g = mix(mix(c00[1],c10[1],dx), mix(c01[1],c11[1],dx), dy);
      const b = mix(mix(c00[2],c10[2],dx), mix(c01[2],c11[2],dx), dy);
      const a = mix(mix(c00[3],c10[3],dx), mix(c01[3],c11[3],dx), dy);
      return [r,g,b,a];
    }

    // 描画（逆写像＋オーバーサンプリング境界埋め）
    function draw(){
      if(!imgData) return;
      const w=canvas.width, h=canvas.height;
      const out = ctx.createImageData(w,h);
      const od = out.data;
      // 1) 逆写像で全ピクセル
      for(let y=0;y<h;y++){
        const gy = Math.floor(y*(gridY/h));
        const v = (y - gy*(h/gridY)) / (h/gridY);
        for(let x=0;x<w;x++){
          const gx = Math.floor(x*(gridX/w));
          const u = (x - gx*(w/gridX)) / (w/gridX);
          const i0 = gy*(gridX+1)+gx;
          const p1=gridPoints[i0], p2=gridPoints[i0+1],
                p3=gridPoints[i0+gridX+1], p4=gridPoints[i0+gridX+2];
          // 双線形で元画像座標
          const sx = (1-u)*(1-v)*p1.origX + u*(1-v)*p2.origX + (1-u)*v*p3.origX + u*v*p4.origX;
          const sy = (1-u)*(1-v)*p1.origY + u*(1-v)*p2.origY + (1-u)*v*p3.origY + u*v*p4.origY;
          const [r,g,b,a] = sampleBilinear(imgData.data, sx, sy);
          const idx = (y*w + x)*4;
          od[idx]=r; od[idx+1]=g; od[idx+2]=b; od[idx+3]=a;
        }
      }
      // 2) 簡易オーバーサンプリングで境界埋め
      const tmp = new Uint8ClampedArray(od);
      for(let y=1;y<h-1;y++){
        for(let x=1;x<w-1;x++){
          const idx=(y*w+x)*4;
          if(od[idx+3] < 255*0.2){  // アルファ薄い→穴とみなす
            // 周囲4方向の平均を埋め込み
            const sum=[0,0,0,0], cnt=[0];
            [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
              const j = ((y+dy)*w + (x+dx))*4;
              if(tmp[j+3]>255*0.8){
                sum[0]+=tmp[j]; sum[1]+=tmp[j+1];
                sum[2]+=tmp[j+2]; sum[3]+=tmp[j+3];
                cnt[0]++;
              }
            });
            if(cnt[0]>0){
              od[idx]=sum[0]/cnt[0];
              od[idx+1]=sum[1]/cnt[0];
              od[idx+2]=sum[2]/cnt[0];
              od[idx+3]=sum[3]/cnt[0];
            }
          }
        }
      }
      ctx.putImageData(out,0,0);
    }

    function saveImage(){
      const link=document.createElement('a');
      link.download='warped.png';
      link.href=canvas.toDataURL();
      link.click();
    }
    </script>
</body>
</html>
