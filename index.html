<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メッシュワープ画像加工</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        canvas {
            border: 3px solid #000;
            max-width: 100%;
            margin: 5px;
            background: #f0f0f0;
        }
        .controls {
            margin: 20px 0;
        }
        .grid-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
        }
        button {
            margin: 5px;
        }
        #error {
            color: red;
        }
    </style>
</head>
<body>
    <h1>メッシュワープ画像加工</h1>
    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <div>
            <label>横の分割数: <input type="range" id="gridX" min="2" max="50" value="5"></label>
            <span id="gridXValue">5</span>
        </div>
        <div>
            <label>縦の分割数: <input type="range" id="gridY" min="2" max="50" value="5"></label>
            <span id="gridYValue">5</span>
        </div>
        <button onclick="resetGrid()">グリッドリセット</button>
        <button onclick="undo()">戻る</button>
        <button onclick="redo()">進む</button>
        <button onclick="saveImage()">画像保存</button>
    </div>
    <div id="error"></div>
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('imageInput');
        const gridXInput = document.getElementById('gridX');
        const gridYInput = document.getElementById('gridY');
        const gridXValue = document.getElementById('gridXValue');
        const gridYValue = document.getElementById('gridYValue');
        const gridContainer = document.getElementById('gridContainer');
        const errorDiv = document.getElementById('error');

        let img = new Image();
        let gridPoints = [];
        let gridX = 5, gridY = 5;
        let isDragging = false;
        let draggedPoint = null;
        let canvasOffset = { x: 0, y: 0 };
        let history = [];
        let historyIndex = -1;

        // エラーメッセージ表示
        function showError(message) {
            errorDiv.textContent = message;
            console.error(message);
        }

        // 画像読み込み
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                showError('画像ファイルが選択されていません。');
                return;
            }
            try {
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.imageSmoothingEnabled = true; // スムーズな補間
                    updateCanvasOffset();
                    initGrid();
                    saveHistory();
                    draw();
                    errorDiv.textContent = '';
                };
                img.onerror = () => {
                    showError('画像の読み込みに失敗しました。');
                };
            } catch (err) {
                showError('画像処理中にエラーが発生しました: ' + err.message);
            }
        });

        // グリッド初期化
        function initGrid() {
            try {
                if (gridX > 30 || gridY > 30) {
                    showError('警告: 分割数が多いとパフォーマンスが低下する可能性があります。');
                }
                gridPoints = [];
                gridContainer.innerHTML = '';
                for (let y = 0; y <= gridY; y++) {
                    for (let x = 0; x <= gridX; x++) {
                        const px = (x / gridX) * canvas.width;
                        const py = (y / gridY) * canvas.height;
                        gridPoints.push({ x: px, y: py, origX: px, origY: py });
                        createGridPoint(px, py, gridPoints.length - 1);
                    }
                }
            } catch (err) {
                showError('グリッド初期化中にエラーが発生しました: ' + err.message);
            }
        }

        // グリッドポイントのDOM要素作成
        function createGridPoint(x, y, index) {
            const point = document.createElement('div');
            point.className = 'grid-point';
            updatePointPosition(point, x, y);
            point.addEventListener('mousedown', () => {
                isDragging = true;
                draggedPoint = index;
            });
            gridContainer.appendChild(point);
        }

        // ポイントの位置更新
        function updatePointPosition(point, x, y) {
            point.style.left = `${canvasOffset.x + x}px`;
            point.style.top = `${canvasOffset.y + y}px`;
        }

        // キャンバスのオフセット更新
        function updateCanvasOffset() {
            const rect = canvas.getBoundingClientRect();
            canvasOffset.x = rect.left;
            canvasOffset.y = rect.top;
        }

        // グリッドリセット
        function resetGrid() {
            try {
                gridPoints.forEach((p, i) => {
                    p.x = p.origX;
                    p.y = p.origY;
                    updatePointPosition(gridContainer.children[i], p.x, p.y);
                });
                saveHistory();
                draw();
            } catch (err) {
                showError('グリッドリセット中にエラーが発生しました: ' + err.message);
            }
        }

        // 履歴保存
        function saveHistory() {
            try {
                history = history.slice(0, historyIndex + 1);
                history.push(JSON.stringify(gridPoints.map(p => ({ x: p.x, y: p.y }))));
                historyIndex++;
                if (history.length > 50) {
                    history.shift();
                    historyIndex--;
                }
            } catch (err) {
                showError('履歴保存中にエラーが発生しました: ' + err.message);
            }
        }

        // 戻る
        function undo() {
            try {
                if (historyIndex > 0) {
                    historyIndex--;
                    gridPoints = JSON.parse(history[historyIndex]).map((p, i) => ({
                        x: p.x,
                        y: p.y,
                        origX: gridPoints[i].origX,
                        origY: gridPoints[i].origY
                    }));
                    updateGridPoints();
                    draw();
                }
            } catch (err) {
                showError('戻る操作中にエラーが発生しました: ' + err.message);
            }
        }

        // 進む
        function redo() {
            try {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    gridPoints = JSON.parse(history[historyIndex]).map((p, i) => ({
                        x: p.x,
                        y: p.y,
                        origX: gridPoints[i].origX,
                        origY: gridPoints[i].origY
                    }));
                    updateGridPoints();
                    draw();
                }
            } catch (err) {
                showError('進む操作中にエラーが発生しました: ' + err.message);
            }
        }

        // グリッドポイント更新
        function updateGridPoints() {
            try {
                gridPoints.forEach((p, i) => {
                    updatePointPosition(gridContainer.children[i], p.x, p.y);
                });
            } catch (err) {
                showError('グリッドポイント更新中にエラーが発生しました: ' + err.message);
            }
        }

        // 画像保存
        function saveImage() {
            try {
                const link = document.createElement('a');
                link.download = 'warped_image.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            } catch (err) {
                showError('画像保存中にエラーが発生しました: ' + err.message);
            }
        }

        // グリッドサイズ変更
        gridXInput.addEventListener('input', () => {
            try {
                gridX = parseInt(gridXInput.value);
                gridXValue.textContent = gridX;
                initGrid();
                saveHistory();
                draw();
            } catch (err) {
                showError('横分割数変更中にエラーが発生しました: ' + err.message);
            }
        });
        gridYInput.addEventListener('input', () => {
            try {
                gridY = parseInt(gridYInput.value);
                gridYValue.textContent = gridY;
                initGrid();
                saveHistory();
                draw();
            } catch (err) {
                showError('縦分割数変更中にエラーが発生しました: ' + err.message);
            }
        });

        // マウスイベント
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedPoint !== null) {
                try {
                    const point = gridPoints[draggedPoint];
                    point.x = e.clientX - canvasOffset.x;
                    point.y = e.clientY - canvasOffset.y;
                    updatePointPosition(gridContainer.children[draggedPoint], point.x, point.y);
                    draw();
                } catch (err) {
                    showError('ドラッグ中にエラーが発生しました: ' + err.message);
                }
            }
        });
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                saveHistory();
            }
            isDragging = false;
            draggedPoint = null;
        });

        // 描画
        function draw() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!img.src) return;

                for (let y = 0; y < gridY; y++) {
                    for (let x = 0; x < gridX; x++) {
                        const i = y * (gridX + 1) + x;
                        const p1 = gridPoints[i];
                        const p2 = gridPoints[i + 1];
                        const p3 = gridPoints[i + gridX + 1];
                        const p4 = gridPoints[i + gridX + 2];

                        const srcX = (x / gridX) * img.width;
                        const srcY = (y / gridY) * img.height;
                        const srcW = img.width / gridX;
                        const srcH = img.height / gridY;

                        warpPerspective(p1, p2, p3, p4, srcX, srcY, srcW, srcH);
                    }
                }
            } catch (err) {
                showError('描画中にエラーが発生しました: ' + err.message);
            }
        }

        // パースペクティブワープ（新実装）
        function warpPerspective(p1, p2, p3, p4, srcX, srcY, srcW, srcH) {
            try {
                // クリッピングパスでメッシュ領域を定義
                ctx.beginPath();
                ctx.moveTo(p1.x, p1.y);
                ctx.lineTo(p2.x, p2.y);
                ctx.lineTo(p4.x, p4.y);
                ctx.lineTo(p3.x, p3.y);
                ctx.closePath();
                ctx.clip();

                // 簡略パースペクティブ変換（アフィン近似）
                const dx1 = p2.x - p1.x, dy1 = p2.y - p1.y;
                const dx2 = p3.x - p1.x, dy2 = p3.y - p1.y;
                const dx3 = p4.x - p2.x - p3.x + p1.x;
                const dy3 = p4.y - p2.y - p3.y + p1.y;

                // 変換行列を適用
                ctx.save();
                ctx.transform(
                    dx1 / srcW, dy1 / srcW,
                    dx2 / srcH, dy2 / srcH,
                    p1.x, p1.y
                );

                // 画像を描画（オーバーラップで隙間防止）
                ctx.drawImage(img, srcX, srcY, srcW * 1.02, srcH * 1.02, 0, 0, srcW * 1.02, srcH * 1.02);

                ctx.restore();
            } catch (err) {
                showError('パースペクティブワープ中にエラーが発生しました: ' + err.message);
            }
        }

        // 初期化
        window.addEventListener('resize', updateCanvasOffset);
    </script>
</body>
</html>
