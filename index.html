<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>メッシュワープ（逆写像＋三角形補間版）</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #container { position: relative; display: inline-block; }
    canvas { border: 3px solid #000; background: #f0f0f0; }
    #gridContainer {
      position: absolute;
      top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .grid-point {
      position: absolute;
      width: 10px; height: 10px;
      background: rgba(255,0,0,0.8);
      border-radius: 50%;
      transform: translate(-50%,-50%);
      cursor: move;
      pointer-events: auto;
    }
    .controls { margin: 20px 0; }
    button, input[type=range] { margin: 5px; }
    #error { color: red; }
  </style>
</head>
<body>
  <h1>メッシュワープ（逆写像＋三角形補間）</h1>
  <div class="controls">
    <input type="file" id="imageInput" accept="image/*">
    <label>横分割: <input type="range" id="gridX" min="2" max="50" value="5"><span id="gridXValue">5</span></label>
    <label>縦分割: <input type="range" id="gridY" min="2" max="50" value="5"><span id="gridYValue">5</span></label>
    <button onclick="resetGrid()">リセット</button>
    <button onclick="undo()">戻る</button>
    <button onclick="redo()">進む</button>
    <button onclick="saveImage()">保存</button>
    <div id="error"></div>
  </div>

  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>
  </div>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx    = canvas.getContext('2d');
  const imgInput = document.getElementById('imageInput');
  const gridXInput = document.getElementById('gridX');
  const gridYInput = document.getElementById('gridY');
  const gridXValue = document.getElementById('gridXValue');
  const gridYValue = document.getElementById('gridYValue');
  const gridContainer = document.getElementById('gridContainer');
  const errorDiv = document.getElementById('error');

  let img = new Image();
  let imgData = null;
  let gridPoints = [];
  let gridX = 5, gridY = 5;
  let isDragging = false, draggedIndex = null;
  let history = [], historyIdx = -1;

  function showError(msg) {
    errorDiv.textContent = msg;
    console.error(msg);
  }

  // 画像読み込み
  imgInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if (!file) return showError('画像を選択してください');
    img.src = URL.createObjectURL(file);
    img.onload = () => {
      canvas.width = img.width;
      canvas.height = img.height;
      initGrid();
      saveHistory();
      // 元画像ピクセルキャッシュ
      ctx.drawImage(img,0,0);
      imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
      draw();
      errorDiv.textContent = '';
    };
    img.onerror = () => showError('画像読み込み失敗');
  });

  // グリッド初期化
  function initGrid() {
    gridContainer.innerHTML = '';
    gridPoints = [];
    if (gridX > 30 || gridY > 30) showError('分割数が多いと重くなります');
    for (let y = 0; y <= gridY; y++) {
      for (let x = 0; x <= gridX; x++) {
        const px = x * (canvas.width/gridX);
        const py = y * (canvas.height/gridY);
        gridPoints.push({ x: px, y: py, origX: px, origY: py });
        createPoint(px,py,gridPoints.length-1);
      }
    }
  }
  function createPoint(x,y,i){
    const d = document.createElement('div');
    d.className = 'grid-point';
    d.style.left = x + 'px';
    d.style.top  = y + 'px';
    d.onmousedown = e => {
      isDragging = true;
      draggedIndex = i;
      // pointer capture も OK
    };
    gridContainer.appendChild(d);
  }
  function updateDOM(){
    gridPoints.forEach((p,i)=>{
      const d = gridContainer.children[i];
      d.style.left = p.x+'px';
      d.style.top  = p.y+'px';
    });
  }

  // ヒストリ
  function saveHistory(){
    history = history.slice(0,historyIdx+1);
    history.push(JSON.stringify(gridPoints));
    historyIdx++;
    if (history.length>50){
      history.shift(); historyIdx--;
    }
  }
  function undo(){
    if(historyIdx>0){
      historyIdx--;
      gridPoints = JSON.parse(history[historyIdx]);
      updateDOM(); draw();
    }
  }
  function redo(){
    if(historyIdx<history.length-1){
      historyIdx++;
      gridPoints = JSON.parse(history[historyIdx]);
      updateDOM(); draw();
    }
  }
  function resetGrid(){
    gridPoints.forEach(p=>{
      p.x = p.origX; p.y = p.origY;
    });
    updateDOM(); saveHistory(); draw();
  }

  gridXInput.oninput = ()=>{
    gridX = +gridXInput.value;
    gridXValue.textContent = gridX;
    initGrid(); saveHistory(); draw();
  };
  gridYInput.oninput = ()=>{
    gridY = +gridYInput.value;
    gridYValue.textContent = gridY;
    initGrid(); saveHistory(); draw();
  };

  // ドラッグ
  document.addEventListener('mousemove', e=>{
    if (!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const p = gridPoints[draggedIndex];
    p.x = Math.max(0,Math.min(canvas.width, x));
    p.y = Math.max(0,Math.min(canvas.height,y));
    updateDOM(); draw();
  });
  document.addEventListener('mouseup', e=>{
    if (isDragging){
      saveHistory();
      isDragging = false;
      draggedIndex = null;
    }
  });

  // バイリニアサンプル
  function sampleBilinear(buf, sx, sy){
    const w = canvas.width, h = canvas.height;
    sx = Math.max(0,Math.min(w-1, sx));
    sy = Math.max(0,Math.min(h-1, sy));
    const x0 = Math.floor(sx), y0 = Math.floor(sy);
    const x1 = Math.min(w-1, x0+1), y1 = Math.min(h-1, y0+1);
    const dx = sx - x0, dy = sy - y0;
    const i00=(y0*w+x0)*4, i10=(y0*w+x1)*4,
          i01=(y1*w+x0)*4, i11=(y1*w+x1)*4;
    const c00=[buf[i00],buf[i00+1],buf[i00+2],buf[i00+3]];
    const c10=[buf[i10],buf[i10+1],buf[i10+2],buf[i10+3]];
    const c01=[buf[i01],buf[i01+1],buf[i01+2],buf[i01+3]];
    const c11=[buf[i11],buf[i11+1],buf[i11+2],buf[i11+3]];
    const mix = (a,b,t)=> a + (b-a)*t;
    const r = mix(mix(c00[0],c10[0],dx), mix(c01[0],c11[0],dx), dy);
    const g = mix(mix(c00[1],c10[1],dx), mix(c01[1],c11[1],dx), dy);
    const b = mix(mix(c00[2],c10[2],dx), mix(c01[2],c11[2],dx), dy);
    const a = mix(mix(c00[3],c10[3],dx), mix(c01[3],c11[3],dx), dy);
    return [r,g,b,a];
  }

  // 三角形逆写像
  function drawTriangle(v0,v1,v2,o0,o1,o2, outBuf, outW, outH){
    const minX = Math.max(0, Math.floor(Math.min(v0.x,v1.x,v2.x)));
    const maxX = Math.min(outW-1, Math.ceil(Math.max(v0.x,v1.x,v2.x)));
    const minY = Math.max(0, Math.floor(Math.min(v0.y,v1.y,v2.y)));
    const maxY = Math.min(outH-1, Math.ceil(Math.max(v0.y,v1.y,v2.y)));
    // 面積（逆数）
    const area = (v1.y - v2.y)*(v0.x - v2.x) + (v2.x - v1.x)*(v0.y - v2.y);
    for(let y=minY; y<=maxY; y++){
      for(let x=minX; x<=maxX; x++){
        const w0 = ((v1.y - v2.y)*(x - v2.x) + (v2.x - v1.x)*(y - v2.y)) / area;
        const w1 = ((v2.y - v0.y)*(x - v2.x) + (v0.x - v2.x)*(y - v2.y)) / area;
        const w2 = 1 - w0 - w1;
        if (w0>=0 && w1>=0 && w2>=0){
          const sx = w0*o0.x + w1*o1.x + w2*o2.x;
          const sy = w0*o0.y + w1*o1.y + w2*o2.y;
          const [r,g,b,a] = sampleBilinear(imgData.data, sx, sy);
          const idx = (y*outW + x)*4;
          outBuf[idx]=r; outBuf[idx+1]=g; outBuf[idx+2]=b; outBuf[idx+3]=a;
        }
      }
    }
  }

  // 描画本体
  function draw(){
    if (!imgData) return;
    const w = canvas.width, h = canvas.height;
    const output = ctx.createImageData(w,h);
    const buf = output.data;

    for(let gy=0; gy<gridY; gy++){
      for(let gx=0; gx<gridX; gx++){
        const i = gy*(gridX+1)+gx;
        const p1 = gridPoints[i],     // TL
              p2 = gridPoints[i+1],   // TR
              p3 = gridPoints[i+gridX+1], // BL
              p4 = gridPoints[i+gridX+2]; // BR
        const o1 = {x:p1.origX, y:p1.origY},
              o2 = {x:p2.origX, y:p2.origY},
              o3 = {x:p3.origX, y:p3.origY},
              o4 = {x:p4.origX, y:p4.origY};

        // 上半分三角形
        drawTriangle(p1,p2,p3, o1,o2,o3, buf,w,h);
        // 下半分三角形
        drawTriangle(p4,p3,p2, o4,o3,o2, buf,w,h);
      }
    }

    // 簡易境界埋め
    const tmp = new Uint8ClampedArray(buf);
    for(let y=1; y<h-1; y++){
      for(let x=1; x<w-1; x++){
        const idx=(y*w+x)*4;
        if (buf[idx+3] < 10){
          let sr=0, sg=0, sb=0, sa=0, cnt=0;
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
            const j = ((y+dy)*w + (x+dx))*4;
            if (tmp[j+3]>200){
              sr+=tmp[j]; sg+=tmp[j+1]; sb+=tmp[j+2]; sa+=tmp[j+3];
              cnt++;
            }
          });
          if(cnt){
            buf[idx]=sr/cnt;
            buf[idx+1]=sg/cnt;
            buf[idx+2]=sb/cnt;
            buf[idx+3]=sa/cnt;
          }
        }
      }
    }

    ctx.putImageData(output,0,0);
  }

  // 保存
  function saveImage(){
    const a = document.createElement('a');
    a.href = canvas.toDataURL();
    a.download = 'warped.png';
    a.click();
  }
  </script>
</body>
</html>
