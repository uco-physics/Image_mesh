<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>メッシュワープ（確定式グリッド更新版）</title>
  <style>
    body { font-family: Arial, sans-serif; text-align: center; margin: 20px; }
    #container { position: relative; display: inline-block; }
    canvas { border: 3px solid #000; background: #f0f0f0; }
    #gridContainer {
      position: absolute; top: 0; left: 0;
      width: 100%; height: 100%;
      pointer-events: none;
    }
    .grid-point {
      position: absolute; width: 10px; height: 10px;
      background: rgba(255,0,0,0.8); border-radius:50%;
      transform: translate(-50%,-50%); cursor: move;
      pointer-events: auto;
    }
    .controls { margin: 20px 0; }
    button, input[type=range] { margin: 5px; }
    #error { color: red; }
  </style>
</head>
<body>
  <h1>メッシュワープ（確定式グリッド更新）</h1>
  <div class="controls">
    <input type="file" id="imageInput" accept="image/*">
    <label>横分割: 
      <input type="range" id="gridX" min="2" max="50" value="5">
      <span id="gridXValue">5</span>
    </label>
    <label>縦分割: 
      <input type="range" id="gridY" min="2" max="50" value="5">
      <span id="gridYValue">5</span>
    </label>
    <button id="applyGridBtn">グリッド更新</button>
    <button onclick="resetGrid()">リセット</button>
    <button onclick="undo()">戻る</button>
    <button onclick="redo()">進む</button>
    <button onclick="saveImage()">保存</button>
    <div id="error"></div>
  </div>

  <div id="container">
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>
  </div>

  <script>
  const canvas = document.getElementById('canvas');
  const ctx    = canvas.getContext('2d');
  const imgInput     = document.getElementById('imageInput');
  const gridXInput   = document.getElementById('gridX');
  const gridYInput   = document.getElementById('gridY');
  const gridXValueEl = document.getElementById('gridXValue');
  const gridYValueEl = document.getElementById('gridYValue');
  const applyGridBtn = document.getElementById('applyGridBtn');
  const gridContainer= document.getElementById('gridContainer');
  const errorDiv     = document.getElementById('error');

  let img       = new Image();
  let imgData   = null;
  let gridPoints= [];
  let gridX     = 5, gridY = 5;              // 現在適用中の分割数
  let pendingX  = 5, pendingY = 5;           // スライダーで変えたが未適用の分割数
  let isDragging= false, dragIdx = null;
  let history   = [], histIdx = -1;

  function showError(msg){
    errorDiv.textContent = msg;
    console.error(msg);
  }

  // 画像読み込み
  imgInput.addEventListener('change', e => {
    const file = e.target.files[0];
    if(!file) return showError('画像を選んでください');
    img.src = URL.createObjectURL(file);
    img.onload = () => {
      canvas.width = img.width;
      canvas.height= img.height;
      // 初回：グリッド初期化＋ベース画像キャッシュ
      initGrid();
      saveHistory();
      ctx.drawImage(img,0,0);
      imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
      draw();
      errorDiv.textContent = '';
    };
    img.onerror = () => showError('画像読み込みに失敗しました');
  });

  // グリッド初期化（current gridX/Y で作る）
  function initGrid(){
    gridContainer.innerHTML = '';
    gridPoints = [];
    if(gridX>30||gridY>30) showError('分割数が多いと重くなります');
    for(let y=0; y<=gridY; y++){
      for(let x=0; x<=gridX; x++){
        const px = x*(canvas.width/gridX),
              py = y*(canvas.height/gridY);
        gridPoints.push({ x:px, y:py, origX:px, origY:py });
        createPoint(px,py,gridPoints.length-1);
      }
    }
  }
  function createPoint(x,y,i){
    const d = document.createElement('div');
    d.className = 'grid-point';
    d.style.left = x+'px';
    d.style.top  = y+'px';
    d.onmousedown = ()=>{ isDragging=true; dragIdx=i; };
    gridContainer.appendChild(d);
  }
  function updateDOM(){
    gridPoints.forEach((p,i)=>{
      const d = gridContainer.children[i];
      d.style.left = p.x+'px';
      d.style.top  = p.y+'px';
    });
  }

  // 履歴
  function saveHistory(){
    history = history.slice(0,histIdx+1);
    history.push(JSON.stringify(gridPoints));
    histIdx++;
    if(history.length>50){ history.shift(); histIdx--; }
  }
  function undo(){
    if(histIdx>0){
      histIdx--;
      gridPoints = JSON.parse(history[histIdx]);
      updateDOM(); draw();
    }
  }
  function redo(){
    if(histIdx<history.length-1){
      histIdx++;
      gridPoints = JSON.parse(history[histIdx]);
      updateDOM(); draw();
    }
  }
  function resetGrid(){
    gridPoints.forEach(p=>{
      p.x=p.origX; p.y=p.origY;
    });
    updateDOM(); saveHistory(); draw();
  }

  // スライダー操作（未適用の pendingX/Y を更新）
  gridXInput.oninput = ()=>{
    pendingX = +gridXInput.value;
    gridXValueEl.textContent = pendingX;
  };
  gridYInput.oninput = ()=>{
    pendingY = +gridYInput.value;
    gridYValueEl.textContent = pendingY;
  };

  // 「グリッド更新」ボタン：変形済み画像を新 base にして新グリッドを初期化
  applyGridBtn.addEventListener('click', ()=>{
    // 1) 現在表示中のキャンバスを imgData にキャッシュ
    imgData = ctx.getImageData(0,0,canvas.width,canvas.height);
    // 2) 新しい分割数を確定
    gridX = pendingX;  
    gridY = pendingY;
    // 3) グリッド再初期化・履歴リセット
    initGrid();
    history = [JSON.stringify(gridPoints)];
    histIdx = 0;
    // 4) 再描画（現状 deform なしの新グリッド）
    draw();
  });

  // ポイントドラッグ
  document.addEventListener('mousemove', e=>{
    if(!isDragging) return;
    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    const p = gridPoints[dragIdx];
    p.x = Math.max(0,Math.min(canvas.width, x));
    p.y = Math.max(0,Math.min(canvas.height, y));
    updateDOM(); draw();
  });
  document.addEventListener('mouseup', ()=>{
    if(isDragging){
      saveHistory();
      isDragging=false; dragIdx=null;
    }
  });

  // バイリニアサンプリング
  function sampleBilinear(buf, sx, sy){
    const w=canvas.width, h=canvas.height;
    sx = Math.max(0,Math.min(w-1, sx));
    sy = Math.max(0,Math.min(h-1, sy));
    const x0=Math.floor(sx), y0=Math.floor(sy);
    const x1=Math.min(w-1,x0+1), y1=Math.min(h-1,y0+1);
    const dx=sx-x0, dy=sy-y0;
    const i00=(y0*w+x0)*4, i10=(y0*w+x1)*4,
          i01=(y1*w+x0)*4, i11=(y1*w+x1)*4;
    const c00=[buf[i00],buf[i00+1],buf[i00+2],buf[i00+3]];
    const c10=[buf[i10],buf[i10+1],buf[i10+2],buf[i10+3]];
    const c01=[buf[i01],buf[i01+1],buf[i01+2],buf[i01+3]];
    const c11=[buf[i11],buf[i11+1],buf[i11+2],buf[i11+3]];
    const mix=(a,b,t)=>a+(b-a)*t;
    return [
      mix(mix(c00[0],c10[0],dx), mix(c01[0],c11[0],dx), dy),
      mix(mix(c00[1],c10[1],dx), mix(c01[1],c11[1],dx), dy),
      mix(mix(c00[2],c10[2],dx), mix(c01[2],c11[2],dx), dy),
      mix(mix(c00[3],c10[3],dx), mix(c01[3],c11[3],dx), dy)
    ];
  }

  // 三角形逆写像描画
  function drawTriangle(v0,v1,v2,o0,o1,o2, buf,w,h){
    const minX = Math.max(0,Math.floor(Math.min(v0.x,v1.x,v2.x))),
          maxX = Math.min(w-1,Math.ceil(Math.max(v0.x,v1.x,v2.x))),
          minY = Math.max(0,Math.floor(Math.min(v0.y,v1.y,v2.y))),
          maxY = Math.min(h-1,Math.ceil(Math.max(v0.y,v1.y,v2.y)));
    const area = (v1.y-v2.y)*(v0.x-v2.x)+(v2.x-v1.x)*(v0.y-v2.y);
    for(let y=minY;y<=maxY;y++){
      for(let x=minX;x<=maxX;x++){
        const w0 = ((v1.y-v2.y)*(x-v2.x)+(v2.x-v1.x)*(y-v2.y))/area;
        const w1 = ((v2.y-v0.y)*(x-v2.x)+(v0.x-v2.x)*(y-v2.y))/area;
        const w2 = 1 - w0 - w1;
        if(w0>=0&&w1>=0&&w2>=0){
          const sx = w0*o0.x + w1*o1.x + w2*o2.x;
          const sy = w0*o0.y + w1*o1.y + w2*o2.y;
          const [r,g,b,a] = sampleBilinear(imgData.data, sx, sy);
          const idx = (y*w + x)*4;
          buf[idx]=r; buf[idx+1]=g; buf[idx+2]=b; buf[idx+3]=a;
        }
      }
    }
  }

  // 全体描画
  function draw(){
    if(!imgData) return;
    const w=canvas.width, h=canvas.height;
    const out = ctx.createImageData(w,h);
    const buf = out.data;

    for(let gy=0;gy<gridY;gy++){
      for(let gx=0;gx<gridX;gx++){
        const i = gy*(gridX+1)+gx;
        const p1=gridPoints[i],   p2=gridPoints[i+1],
              p3=gridPoints[i+gridX+1], p4=gridPoints[i+gridX+2];
        const o1={x:p1.origX,y:p1.origY},
              o2={x:p2.origX,y:p2.origY},
              o3={x:p3.origX,y:p3.origY},
              o4={x:p4.origX,y:p4.origY};

        drawTriangle(p1,p2,p3, o1,o2,o3, buf,w,h);
        drawTriangle(p4,p3,p2, o4,o3,o2, buf,w,h);
      }
    }

    // 簡易穴埋め
    const tmp=new Uint8ClampedArray(buf);
    for(let y=1;y<h-1;y++){
      for(let x=1;x<w-1;x++){
        const idx=(y*w+x)*4;
        if(buf[idx+3]<10){
          let sr=0,sg=0,sb=0,sa=0,c=0;
          [[1,0],[-1,0],[0,1],[0,-1]].forEach(([dx,dy])=>{
            const j=((y+dy)*w+(x+dx))*4;
            if(tmp[j+3]>200){
              sr+=tmp[j]; sg+=tmp[j+1];
              sb+=tmp[j+2]; sa+=tmp[j+3]; c++;
            }
          });
          if(c){
            buf[idx]=sr/c; buf[idx+1]=sg/c;
            buf[idx+2]=sb/c; buf[idx+3]=sa/c;
          }
        }
      }
    }

    ctx.putImageData(out,0,0);
  }

  // 保存
  function saveImage(){
    const a=document.createElement('a');
    a.href=canvas.toDataURL();
    a.download='warped.png';
    a.click();
  }
  </script>
</body>
</html>
