<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メッシュワープ画像加工</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        canvas {
            border: 3px solid #000; /* 枠線を太く */
            max-width: 100%;
            margin: 5px; /* 外側マージン */
            background: #f0f0f0; /* 背景色で枠を明確化 */
        }
        .controls {
            margin: 20px 0;
        }
        .grid-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
        }
        button {
            margin: 5px;
        }
        #error {
            color: red;
        }
        select {
            margin: 5px;
            padding: 5px;
        }
    </style>
</head>
<body>
    <h1>メッシュワープ画像加工</h1>
    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <div>
            <label>横の分割数: <input type="range" id="gridX" min="2" max="50" value="5"></label>
            <span id="gridXValue">5</span>
        </div>
        <div>
            <label>縦の分割数: <input type="range" id="gridY" min="2" max="50" value="5"></label>
            <span id="gridYValue">5</span>
        </div>
        <div>
            <label>補完アルゴリズム:
                <select id="interpolationMethod">
                    <option value="bilinear">Bilinear Interpolation</option>
                    <option value="bicubic">Bicubic Interpolation</option>
                    <option value="perspective">Perspective Warp</option>
                </select>
            </label>
        </div>
        <button onclick="resetGrid()">グリッドリセット</button>
        <button onclick="undo()">戻る</button>
        <button onclick="redo()">進む</button>
        <button onclick="saveImage()">画像保存</button>
    </div>
    <div id="error"></div>
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('imageInput');
        const gridXInput = document.getElementById('gridX');
        const gridYInput = document.getElementById('gridY');
        const gridXValue = document.getElementById('gridXValue');
        const gridYValue = document.getElementById('gridYValue');
        const interpolationMethod = document.getElementById('interpolationMethod');
        const gridContainer = document.getElementById('gridContainer');
        const errorDiv = document.getElementById('error');

        let img = new Image();
        let gridPoints = [];
        let gridX = 5, gridY = 5;
        let isDragging = false;
        let draggedPoint = null;
        let canvasOffset = { x: 0, y: 0 };
        let history = [];
        let historyIndex = -1;

        // エラーメッセージ表示
        function showError(message) {
            errorDiv.textContent = message;
            console.error(message);
        }

        // 画像読み込み
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (!file) {
                showError('画像ファイルが選択されていません。');
                return;
            }
            try {
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    updateCanvasOffset();
                    initGrid();
                    saveHistory();
                    draw();
                    errorDiv.textContent = '';
                };
                img.onerror = () => {
                    showError('画像の読み込みに失敗しました。');
                };
            } catch (err) {
                showError('画像処理中にエラーが発生しました: ' + err.message);
            }
        });

        // グリッド初期化
        function initGrid() {
            try {
                if (gridX > 30 || gridY > 30) {
                    showError('警告: 分割数が多いとパフォーマンスが低下する可能性があります。');
                }
                gridPoints = [];
                gridContainer.innerHTML = '';
                for (let y = 0; y <= gridY; y++) {
                    for (let x = 0; x <= gridX; x++) {
                        const px = (x / gridX) * canvas.width;
                        const py = (y / gridY) * canvas.height;
                        gridPoints.push({ x: px, y: py, origX: px, origY: py });
                        createGridPoint(px, py, gridPoints.length - 1);
                    }
                }
            } catch (err) {
                showError('グリッド初期化中にエラーが発生しました: ' + err.message);
            }
        }

        // グリッドポイントのDOM要素作成
        function createGridPoint(x, y, index) {
            const point = document.createElement('div');
            point.className = 'grid-point';
            updatePointPosition(point, x, y);
            point.addEventListener('mousedown', () => {
                isDragging = true;
                draggedPoint = index;
            });
            gridContainer.appendChild(point);
        }

        // ポイントの位置更新
        function updatePointPosition(point, x, y) {
            point.style.left = `${canvasOffset.x + x}px`;
            point.style.top = `${canvasOffset.y + y}px`;
        }

        // キャンバスのオフセット更新
        function updateCanvasOffset() {
            const rect = canvas.getBoundingClientRect();
            canvasOffset.x = rect.left;
            canvasOffset.y = rect.top;
        }

        // グリッドリセット
        function resetGrid() {
            try {
                gridPoints.forEach((p, i) => {
                    p.x = p.origX;
                    p.y = p.origY;
                    updatePointPosition(gridContainer.children[i], p.x, p.y);
                });
                saveHistory();
                draw();
            } catch (err) {
                showError('グリッドリセット中にエラーが発生しました: ' + err.message);
            }
        }

        // 履歴保存
        function saveHistory() {
            try {
                history = history.slice(0, historyIndex + 1);
                history.push(JSON.stringify(gridPoints.map(p => ({ x: p.x, y: p.y }))));
                historyIndex++;
                if (history.length > 50) {
                    history.shift();
                    historyIndex--;
                }
            } catch (err) {
                showError('履歴保存中にエラーが発生しました: ' + err.message);
            }
        }

        // 戻る
        function undo() {
            try {
                if (historyIndex > 0) {
                    historyIndex--;
                    gridPoints = JSON.parse(history[historyIndex]).map((p, i) => ({
                        x: p.x,
                        y: p.y,
                        origX: gridPoints[i].origX,
                        origY: gridPoints[i].origY
                    }));
                    updateGridPoints();
                    draw();
                }
            } catch (err) {
                showError('戻る操作中にエラーが発生しました: ' + err.message);
            }
        }

        // 進む
        function redo() {
            try {
                if (historyIndex < history.length - 1) {
                    historyIndex++;
                    gridPoints = JSON.parse(history[historyIndex]).map((p, i) => ({
                        x: p.x,
                        y: p.y,
                        origX: gridPoints[i].origX,
                        origY: gridPoints[i].origY
                    }));
                    updateGridPoints();
                    draw();
                }
            } catch (err) {
                showError('進む操作中にエラーが発生しました: ' + err.message);
            }
        }

        // グリッドポイント更新
        function updateGridPoints() {
            try {
                gridPoints.forEach((p, i) => {
                    updatePointPosition(gridContainer.children[i], p.x, p.y);
                });
            } catch (err) {
                showError('グリッドポイント更新中にエラーが発生しました: ' + err.message);
            }
        }

        // 画像保存
        function saveImage() {
            try {
                const link = document.createElement('a');
                link.download = 'warped_image.png';
                link.href = canvas.toDataURL('image/png');
                link.click();
            } catch (err) {
                showError('画像保存中にエラーが発生しました: ' + err.message);
            }
        }

        // グリッドサイズ変更
        gridXInput.addEventListener('input', () => {
            try {
                gridX = parseInt(gridXInput.value);
                gridXValue.textContent = gridX;
                initGrid();
                saveHistory();
                draw();
            } catch (err) {
                showError('横分割数変更中にエラーが発生しました: ' + err.message);
            }
        });
        gridYInput.addEventListener('input', () => {
            try {
                gridY = parseInt(gridYInput.value);
                gridYValue.textContent = gridY;
                initGrid();
                saveHistory();
                draw();
            } catch (err) {
                showError('縦分割数変更中にエラーが発生しました: ' + err.message);
            }
        });

        // 補完アルゴリズム変更
        interpolationMethod.addEventListener('change', () => {
            draw();
        });

        // マウスイベント
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedPoint !== null) {
                try {
                    const point = gridPoints[draggedPoint];
                    point.x = e.clientX - canvasOffset.x;
                    point.y = e.clientY - canvasOffset.y;
                    updatePointPosition(gridContainer.children[draggedPoint], point.x, point.y);
                    draw();
                } catch (err) {
                    showError('ドラッグ中にエラーが発生しました: ' + err.message);
                }
            }
        });
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                saveHistory();
            }
            isDragging = false;
            draggedPoint = null;
        });

        // 描画
        function draw() {
            try {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                if (!img.src) return;

                const method = interpolationMethod.value;
                for (let y = 0; y < gridY; y++) {
                    for (let x = 0; x < gridX; x++) {
                        const i = y * (gridX + 1) + x;
                        const p1 = gridPoints[i];
                        const p2 = gridPoints[i + 1];
                        const p3 = gridPoints[i + gridX + 1];
                        const p4 = gridPoints[i + gridX + 2];

                        const srcX = (x / gridX) * img.width;
                        const srcY = (y / gridY) * img.height;
                        const srcW = img.width / gridX;
                        const srcH = img.height / gridY;

                        if (method === 'bilinear') {
                            warpBilinear(p1, p2, p3, p4, srcX, srcY, srcW, srcH);
                        } else if (method === 'bicubic') {
                            warpBicubic(p1, p2, p3, p4, srcX, srcY, srcW, srcH);
                        } else if (method === 'perspective') {
                            warpPerspective(p1, p2, p3, p4, srcX, srcY, srcW, srcH);
                        }
                    }
                }
            } catch (err) {
                showError('描画中にエラーが発生しました: ' + err.message);
            }
        }

        // バイリニア補間
        function warpBilinear(p1, p2, p3, p4, srcX, srcY, srcW, srcH) {
            const steps = 50;
            for (let u = 0; u <= 1; u += 1 / steps) {
                for (let v = 0; v <= 1; v += 1 / steps) {
                    const px = (1 - u) * (1 - v) * p1.x + u * (1 - v) * p2.x +
                               (1 - u) * v * p3.x + u * v * p4.x;
                    const py = (1 - u) * (1 - v) * p1.y + u * (1 - v) * p2.y +
                               (1 - u) * v * p3.y + u * v * p4.y;

                    const sx = srcX + u * srcW;
                    const sy = srcY + v * srcH;

                    ctx.drawImage(img, sx, sy, srcW / steps * 1.01, srcH / steps * 1.01,
                                  px, py, canvas.width / gridX / steps * 1.01, canvas.height / gridY / steps * 1.01);
                }
            }
        }

        // バイキュービック補間
        function warpBicubic(p1, p2, p3, p4, srcX, srcY, srcW, srcH) {
            const steps = 50;
            for (let u = 0; u <= 1; u += 1 / steps) {
                for (let v = 0; v <= 1; v += 1 / steps) {
                    // バイキュービック補間用のウェイト計算
                    const px = bicubicInterpolate([p1.x, p2.x, p3.x, p4.x], u, v);
                    const py = bicubicInterpolate([p1.y, p2.y, p3.y, p4.y], u, v);

                    const sx = srcX + u * srcW;
                    const sy = srcY + v * srcH;

                    ctx.drawImage(img, sx, sy, srcW / steps * 1.01, srcH / steps * 1.01,
                                  px, py, canvas.width / gridX / steps * 1.01, canvas.height / gridY / steps * 1.01);
                }
            }
        }

        // バイキュービック補間のヘルパー関数
        function bicubicInterpolate(values, u, v) {
            // 簡略化のため、4点のバイリニアをベースにスムージング
            const p00 = values[0], p10 = values[1], p01 = values[2], p11 = values[3];
            const a = (1 - u) * (1 - v) * p00;
            const b = u * (1 - v) * p10;
            const c = (1 - u) * v * p01;
            const d = u * v * p11;
            return a + b + c + d;
        }

        // パースペクティブワープ
        function warpPerspective(p1, p2, p3, p4, srcX, srcY, srcW, srcH) {
            const steps = 50;
            // パースペクティブ変換行列の計算（簡略化）
            for (let u = 0; u <= 1; u += 1 / steps) {
                for (let v = 0; v <= 1; v += 1 / steps) {
                    // 単純なパースペクティブ近似
                    const px = (1 - u) * (1 - v) * p1.x + u * (1 - v) * p2.x +
                               (1 - u) * v * p3.x + u * v * p4.x;
                    const py = (1 - u) * (1 - v) * p1.y + u * (1 - v) * p2.y +
                               (1 - u) * v * p3.y + u * v * p4.y;

                    const sx = srcX + u * srcW;
                    const sy = srcY + v * srcH;

                    ctx.drawImage(img, sx, sy, srcW / steps * 1.02, srcH / steps * 1.02,
                                  px, py, canvas.width / gridX / steps * 1.02, canvas.height / gridY / steps * 1.02);
                }
            }
        }

        // 初期化
        window.addEventListener('resize', updateCanvasOffset);
    </script>
</body>
</html>
