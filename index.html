<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>メッシュワープ画像加工</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            text-align: center;
            margin: 20px;
        }
        canvas {
            border: 1px solid #000;
            max-width: 100%;
        }
        .controls {
            margin: 20px 0;
        }
        .grid-point {
            position: absolute;
            width: 8px;
            height: 8px;
            background: red;
            border-radius: 50%;
            transform: translate(-50%, -50%);
            cursor: move;
        }
        button {
            margin: 5px;
        }
    </style>
</head>
<body>
    <h1>メッシュワープ画像加工</h1>
    <div class="controls">
        <input type="file" id="imageInput" accept="image/*">
        <div>
            <label>横の分割数: <input type="range" id="gridX" min="2" max="20" value="5"></label>
            <span id="gridXValue">5</span>
        </div>
        <div>
            <label>縦の分割数: <input type="range" id="gridY" min="2" max="20" value="5"></label>
            <span id="gridYValue">5</span>
        </div>
        <button onclick="resetGrid()">グリッドリセット</button>
        <button onclick="undo()">戻る</button>
        <button onclick="redo()">進む</button>
        <button onclick="saveImage()">画像保存</button>
    </div>
    <canvas id="canvas"></canvas>
    <div id="gridContainer"></div>

    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const imageInput = document.getElementById('imageInput');
        const gridXInput = document.getElementById('gridX');
        const gridYInput = document.getElementById('gridY');
        const gridXValue = document.getElementById('gridXValue');
        const gridYValue = document.getElementById('gridYValue');
        const gridContainer = document.getElementById('gridContainer');

        let img = new Image();
        let gridPoints = [];
        let gridX = 5, gridY = 5;
        let isDragging = false;
        let draggedPoint = null;
        let canvasOffset = { x: 0, y: 0 };
        let history = [];
        let historyIndex = -1;

        // 画像読み込み
        imageInput.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) {
                img.src = URL.createObjectURL(file);
                img.onload = () => {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    updateCanvasOffset();
                    initGrid();
                    saveHistory();
                    draw();
                };
            }
        });

        // グリッド初期化
        function initGrid() {
            gridPoints = [];
            gridContainer.innerHTML = '';
            for (let y = 0 ipsa; y <= gridY; y++) {
                for (let x = 0; x <= gridX; x++) {
                    const px = (x / gridX) * canvas.width;
                    const py = (y / gridY) * canvas.height;
                    gridPoints.push({ x: px, y: py, origX: px, origY: py });
                    createGridPoint(px, py, gridPoints.length - 1);
                }
            }
        }

        // グリッドポイントのDOM要素作成
        function createGridPoint(x, y, index) {
            const point = document.createElement('div');
            point.className = 'grid-point';
            updatePointPosition(point, x, y);
            point.addEventListener('mousedown', () => {
                isDragging = true;
                draggedPoint = index;
            });
            gridContainer.appendChild(point);
        }

        // ポイントの位置更新
        function updatePointPosition(point, x, y) {
            point.style.left = `${canvasOffset.x + x}px`;
            point.style.top = `${canvasOffset.y + y}px`;
        }

        // キャンバスのオフセット更新
        function updateCanvasOffset() {
            const rect = canvas.getBoundingClientRect();
            canvasOffset.x = rect.left;
            canvasOffset.y = rect.top;
        }

        // グリッドリセット
        function resetGrid() {
            gridPoints.forEach((p, i) => {
                p.x = p.origX;
                p.y = p.origY;
                updatePointPosition(gridContainer.children[i], p.x, p.y);
            });
            saveHistory();
            draw();
        }

        // 履歴保存
        function saveHistory() {
            history = history.slice(0, historyIndex + 1);
            history.push(JSON.stringify(gridPoints.map(p => ({ x: p.x, y: p.y }))));
            historyIndex++;
            if (history.length > 50) { // 履歴上限
                history.shift();
                historyIndex--;
            }
        }

        // 戻る
        function undo() {
            if (historyIndex > 0) {
                historyIndex--;
                gridPoints = JSON.parse(history[historyIndex]).map((p, i) => ({
                    x: p.x,
                    y: p.y,
                    origX: gridPoints[i].origX,
                    origY: gridPoints[i].origY
                }));
                updateGridPoints();
                draw();
            }
        }

        // 進む
        function redo() {
            if (historyIndex < history.length - 1) {
                historyIndex++;
                gridPoints = JSON.parse(history[historyIndex]).map((p, i) => ({
                    x: p.x,
                    y: p.y,
                    origX: gridPoints[i].origX,
                    origY: gridPoints[i].origY
                }));
                updateGridPoints();
                draw();
            }
        }

        // グリッドポイント更新
        function updateGridPoints() {
            gridPoints.forEach((p, i) => {
                updatePointPosition(gridContainer.children[i], p.x, p.y);
            });
        }

        // 画像保存
        function saveImage() {
            const link = document.createElement('a');
            link.download = 'warped_image.png';
            link.href = canvas.toDataURL('image/png');
            link.click();
        }

        // グリッドサイズ変更
        gridXInput.addEventListener('input', () => {
            gridX = parseInt(gridXInput.value);
            gridXValue.textContent = gridX;
            initGrid();
            saveHistory();
            draw();
        });
        gridYInput.addEventListener('input', () => {
            gridY = parseInt(gridYInput.value);
            gridYValue.textContent = gridY;
            initGrid();
            saveHistory();
            draw();
        });

        // マウスイベント
        document.addEventListener('mousemove', (e) => {
            if (isDragging && draggedPoint !== null) {
                const point = gridPoints[draggedPoint];
                point.x = e.clientX - canvasOffset.x;
                point.y = e.clientY - canvasOffset.y;
                updatePointPosition(gridContainer.children[draggedPoint], point.x, point.y);
                draw();
            }
        });
        document.addEventListener('mouseup', () => {
            if (isDragging) {
                saveHistory();
            }
            isDragging = false;
            draggedPoint = null;
        });

        // 描画
        function draw() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            if (!img.src) return;

            for (let y = 0; y < gridY; y++) {
                for (let x = 0; x < gridX; x++) {
                    const i = y * (gridX + 1) + x;
                    const p1 = gridPoints[i];
                    const p2 = gridPoints[i + 1];
                    const p3 = gridPoints[i + gridX + 1];
                    const p4 = gridPoints[i + gridX + 2];

                    // 元画像の矩形
                    const srcX = (x / gridX) * img.width;
                    const srcY = (y / gridY) * img.height;
                    const srcW = img.width / gridX;
                    const srcH = img.height / gridY;

                    // メッシュワープ
                    warpQuad(p1, p2, p3, p4, srcX, srcY, srcW, srcH);
                }
            }
        }

        // メッシュワープの実装（白い縞の修正）
        function warpQuad(p1, p2, p3, p4, srcX, srcY, srcW, srcH) {
            const steps = 50; // ステップ数を増やして隙間を減らす
            for (let u = 0; u <= 1; u += 1 / steps) {
                for (let v = 0; v <= 1; v += 1 / steps) {
                    // バイリニア補間
                    const px = (1 - u) * (1 - v) * p1.x + u * (1 - v) * p2.x +
                               (1 - u) * v * p3.x + u * v * p4.x;
                    const py = (1 - u) * (1 - v) * p1.y + u * (1 - v) * p2.y +
                               (1 - u) * v * p3.y + u * v * p4.y;

                    const sx = srcX + u * srcW;
                    const sy = srcY + v * srcH;

                    // わずかにオーバーラップさせる
                    ctx.drawImage(img, sx, sy, srcW / steps * 1.01, srcH / steps * 1.01,
                                  px, py, canvas.width / gridX / steps * 1.01, canvas.height / gridY / steps * 1.01);
                }
            }
        }

        // 初期化
        window.addEventListener('resize', updateCanvasOffset);
    </script>
</body>
</html>
