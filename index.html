<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Mesh Warp – コミットツリー版</title>

  <!-- Tailwind CSS CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <script>
    tailwind.config = {
      theme: {
        extend: {
          colors: {
            primary: '#4F46E5',
            secondary: '#10B981'
          }
        }
      }
    }
  </script>

  <!-- Google Fonts: Inter -->
  <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
  <!-- Font Awesome (Kit ID を your-kit-id に置き換え) -->
  <script src="https://kit.fontawesome.com/your-kit-id.js" crossorigin="anonymous"></script>

  <!-- カスタムスタイル -->
  <link rel="stylesheet" href="style.css">
</head>

<body class="bg-gray-50 font-inter text-gray-800">
  <header class="bg-white/80 backdrop-blur sticky top-0 z-10 p-4 shadow-sm">
    <h1 class="text-2xl font-bold text-primary text-center">メッシュワープ（コミットツリー版）</h1>
  </header>

  <main class="py-6 px-4 space-y-6 max-w-4xl mx-auto">
    <!-- コントロールパネル -->
    <section class="controls bg-white p-6 rounded-2xl shadow-lg grid gap-4 lg:grid-cols-2">
      <div class="flex flex-col">
        <label for="imageInput" class="font-semibold mb-1">画像ロード</label>
        <input type="file" id="imageInput" accept="image/*" class="block">
      </div>

      <label class="flex flex-col">
        <span class="font-semibold">横分割</span>
        <input type="range" id="gridX" min="2" max="50" value="5" class="h-2 bg-gray-200 rounded-lg">
        <span id="gridXValue" class="mt-1 text-right text-sm text-gray-600">5</span>
      </label>

      <label class="flex flex-col">
        <span class="font-semibold">縦分割</span>
        <input type="range" id="gridY" min="2" max="50" value="5" class="h-2 bg-gray-200 rounded-lg">
        <span id="gridYValue" class="mt-1 text-right text-sm text-gray-600">5</span>
      </label>

      <div class="col-span-full flex flex-wrap gap-2 justify-center">
        <button id="applyGridBtn" class="btn-primary">
          <i class="fas fa-grip-lines"></i> グリッド更新
        </button>
        <button id="undoBtn" class="btn-outline">
          <i class="fas fa-undo"></i> 戻る
        </button>
        <button id="redoBtn" class="btn-outline">
          <i class="fas fa-redo"></i> 進む
        </button>
        <button id="resetBtn" class="btn-outline">
          <i class="fas fa-sync-alt"></i> リセット
        </button>
        <button id="saveBtn" class="btn-primary">
          <i class="fas fa-download"></i> 保存
        </button>
      </div>

      <div id="error" class="col-span-full text-red-600 h-5"></div>
    </section>

    <!-- キャンバス＋グリッドポイント -->
    <section class="relative inline-block">
      <canvas id="canvas" class="border-4 border-gray-800 bg-white"></canvas>
      <div id="gridContainer" class="absolute inset-0"></div>
    </section>
  </main>

  <!-- オリジナルの JavaScript をここにペースト -->
  <script>
    // --- コミットクラス ---
    class Commit {
      constructor(parent, imgData, gridX, gridY, initialPoints) {
        this.parent    = parent;
        this.children  = [];
        this.imgData   = imgData;
        this.gridX     = gridX;
        this.gridY     = gridY;
        this.snapshots = [];
        this.idx       = -1;
        this.push(initialPoints);
      }
      push(points) {
        this.snapshots = this.snapshots.slice(0, this.idx + 1);
        this.snapshots.push(points.map(p => ({ x:p.x, y:p.y, origX:p.origX, origY:p.origY })));
        this.idx++;
      }
      currentPoints() {
        return this.snapshots[this.idx].map(p => ({ ...p }));
      }
    }

    // --- グローバル ---
    const canvas = document.getElementById('canvas');
    const ctx    = canvas.getContext('2d');
    const imgInput     = document.getElementById('imageInput');
    const gridXInput   = document.getElementById('gridX');
    const gridYInput   = document.getElementById('gridY');
    const gridXValueEl = document.getElementById('gridXValue');
    const gridYValueEl = document.getElementById('gridYValue');
    const applyGridBtn = document.getElementById('applyGridBtn');
    const undoBtn      = document.getElementById('undoBtn');
    const redoBtn      = document.getElementById('redoBtn');
    const resetBtn     = document.getElementById('resetBtn');
    const saveBtn      = document.getElementById('saveBtn');
    const gridContainer= document.getElementById('gridContainer');
    const errorDiv     = document.getElementById('error');

    let img, imgData, gridPoints = [], pendingX = 5, pendingY = 5;
    let rootCommit = null, currentCommit = null;
    let isDragging = false, dragIdx = null;

    function showError(msg) {
      errorDiv.textContent = msg;
      console.error(msg);
    }
    function sampleBilinear(buf, sx, sy) {
      const w=canvas.width, h=canvas.height;
      sx = Math.max(0, Math.min(w-1, sx));
      sy = Math.max(0, Math.min(h-1, sy));
      const x0 = Math.floor(sx), y0 = Math.floor(sy);
      const x1 = Math.min(w-1, x0+1), y1 = Math.min(h-1, y0+1);
      const dx = sx - x0, dy = sy - y0;
      const i00=(y0*w+x0)*4, i10=(y0*w+x1)*4,
            i01=(y1*w+x0)*4, i11=(y1*w+x1)*4;
      const c00=[buf[i00],buf[i00+1],buf[i00+2],buf[i00+3]];
      const c10=[buf[i10],buf[i10+1],buf[i10+2],buf[i10+3]];
      const c01=[buf[i01],buf[i01+1],buf[i01+2],buf[i01+3]];
      const c11=[buf[i11],buf[i11+1],buf[i11+2],buf[i11+3]];
      const mix=(a,b,t)=>a+(b-a)*t;
      const r = mix(mix(c00[0],c10[0],dx), mix(c01[0],c11[0],dx), dy);
      const g = mix(mix(c00[1],c10[1],dx), mix(c01[1],c11[1],dx), dy);
      const b = mix(mix(c00[2],c10[2],dx), mix(c01[2],c11[2],dx), dy);
      const a = mix(mix(c00[3],c10[3],dx), mix(c01[3],c11[3],dx), dy);
      return [r,g,b,a];
    }
    function drawTriangle(v0,v1,v2,o0,o1,o2, buf, w,h){
      const minX = Math.max(0,Math.floor(Math.min(v0.x,v1.x,v2.x)));
      const maxX = Math.min(w-1,Math.ceil (Math.max(v0.x,v1.x,v2.x)));
      const minY = Math.max(0,Math.floor(Math.min(v0.y,v1.y,v2.y)));
      const maxY = Math.min(h-1,Math.ceil (Math.max(v0.y,v1.y,v2.y)));
      const area = (v1.y-v2.y)*(v0.x-v2.x) + (v2.x-v1.x)*(v0.y-v2.y);
      for(let y=minY; y<=maxY; y++){
        for(let x=minX; x<=maxX; x++){
          const w0 = ((v1.y-v2.y)*(x-v2.x) + (v2.x-v1.x)*(y-v2.y)) / area;
          const w1 = ((v2.y-v0.y)*(x-v2.x) + (v0.x-v2.x)*(y-v2.y)) / area;
          const w2 = 1 - w0 - w1;
          if(w0>=0 && w1>=0 && w2>=0){
            const sx = w0*o0.x + w1*o1.x + w2*o2.x;
            const sy = w0*o0.y + w1*o1.y + w2*o2.y;
            const [r,g,b,a] = sampleBilinear(imgData.data, sx, sy);
            const idx = (y*w + x)*4;
            buf[idx]=r; buf[idx+1]=g; buf[idx+2]=b; buf[idx+3]=a;
          }
        }
      }
    }

    function draw() {
      if (!imgData) return;
      const w=canvas.width, h=canvas.height;
      const output = ctx.createImageData(w,h);
      const buf = output.data;
      for(let gy=0; gy<currentCommit.gridY; gy++){
        for(let gx=0; gx<currentCommit.gridX; gx++){
          const i = gy*(currentCommit.gridX+1) + gx;
          const p1=gridPoints[i], p2=gridPoints[i+1],
                p3=gridPoints[i+currentCommit.gridX+1],
                p4=gridPoints[i+currentCommit.gridX+2];
          const o1={x:p1.origX,y:p1.origY},o2={x:p2.origX,y:p2.origY},
                o3={x:p3.origX,y:p3.origY},o4={x:p4.origX,y:p4.origY};
          drawTriangle(p1,p2,p3,o1,o2,o3,buf,w,h);
          drawTriangle(p4,p3,p2,o4,o3,o2,buf,w,h);
        }
      }
      ctx.putImageData(output,0,0);
    }

    function createPoint(x,y,i){
      const d = document.createElement('div');
      d.className = 'grid-point';
      d.style.left = x+'px';
      d.style.top  = y+'px';
      d.onmousedown = ()=>{ isDragging=true; dragIdx=i; };
      gridContainer.appendChild(d);
    }
    function initGridCommit(c){
      ctx.putImageData(c.imgData,0,0);
      imgData = c.imgData;
      gridXInput.value = c.gridX;
      gridYInput.value = c.gridY;
      gridXValueEl.textContent = c.gridX;
      gridYValueEl.textContent = c.gridY;
      pendingX = c.gridX;
      pendingY = c.gridY;
      gridPoints = c.currentPoints();
      gridContainer.innerHTML = '';
      gridPoints.forEach((p,i)=> createPoint(p.x,p.y,i));
    }

    imgInput.addEventListener('change',e=>{
      const file=e.target.files[0];
      if(!file) return showError('画像を選択してください');
      img = new Image();
      img.src = URL.createObjectURL(file);
      img.onload = ()=>{
        canvas.width = img.width;
        canvas.height= img.height;
        ctx.drawImage(img,0,0);
        const base = ctx.getImageData(0,0,canvas.width,canvas.height);
        const initPoints=[];
        const gx=+gridXInput.value, gy=+gridYInput.value;
        for(let y=0;y<=gy;y++){
          for(let x=0;x<=gx;x++){
            initPoints.push({
              x: x*(canvas.width/gx),
              y: y*(canvas.height/gy),
              origX:x*(canvas.width/gx),
              origY:y*(canvas.height/gy)
            });
          }
        }
        rootCommit = new Commit(null,base,gx,gy,initPoints);
        currentCommit = rootCommit;
        initGridCommit(rootCommit);
        draw();
        errorDiv.textContent = '';
      };
      img.onerror = ()=> showError('画像読み込み失敗');
    });

    applyGridBtn.addEventListener('click',()=>{
      const newBase = ctx.getImageData(0,0,canvas.width,canvas.height);
      const nx=pendingX, ny=pendingY;
      const pts=[];
      for(let y=0;y<=ny;y++){
        for(let x=0;x<=nx;x++){
          pts.push({
            x: x*(canvas.width/nx),
            y: y*(canvas.height/ny),
            origX:x*(canvas.width/nx),
            origY:y*(canvas.height/ny)
          });
        }
      }
      const c=new Commit(currentCommit,newBase,nx,ny,pts);
      currentCommit.children.push(c);
      currentCommit=c;
      initGridCommit(c);
      draw();
    });

    undoBtn.addEventListener('click',()=>{
      if(!currentCommit) return;
      if(currentCommit.idx>0) currentCommit.idx--;
      else if(currentCommit.parent) currentCommit=currentCommit.parent;
      initGridCommit(currentCommit);
      draw();
    });

    redoBtn.addEventListener('click',()=>{
      if(!currentCommit) return;
      if(currentCommit.idx<currentCommit.snapshots.length-1) currentCommit.idx++;
      else if(currentCommit.children.length===1) currentCommit=currentCommit.children[0];
      initGridCommit(currentCommit);
      draw();
    });

    resetBtn.addEventListener('click',()=>{
      currentCommit.idx=0;
      initGridCommit(currentCommit);
      draw();
    });

    saveBtn.addEventListener('click',()=>{
      const a=document.createElement('a');
      a.href=canvas.toDataURL();
      a.download='warped.png';
      a.click();
    });

    document.addEventListener('mousemove',e=>{
      if(!isDragging) return;
      const rect=canvas.getBoundingClientRect();
      const x=e.clientX-rect.left, y=e.clientY-rect.top;
      const p=gridPoints[dragIdx];
      p.x=Math.max(0,Math.min(canvas.width,x));
      p.y=Math.max(0,Math.min(canvas.height,y));
      const d=gridContainer.children[dragIdx];
      d.style.left=p.x+'px';
      d.style.top =p.y+'px';
      currentCommit.push(gridPoints);
      draw();
    });

    document.addEventListener('mouseup',()=>{
      isDragging=false;
      dragIdx=null;
    });

    gridXInput.addEventListener('input',()=>{
      pendingX=+gridXInput.value;
      gridXValueEl.textContent=pendingX;
    });
    gridYInput.addEventListener('input',()=>{
      pendingY=+gridYInput.value;
      gridYValueEl.textContent=pendingY;
    });
  </script>
</body>
</html>
